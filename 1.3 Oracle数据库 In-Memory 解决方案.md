## 1.3 Oracle数据库 In-Memory 解决方案

Oracle Database In-Memory（Database In-Memory）功能集包括内存中列存储（IM列存储），高级查询优化和可用性解决方案。

Database In-Memory 优化使分析查询能够在数据仓库和混合使用数据库上运行更快的数量级。

### 1.3.1 Database In-Memory 是什么?

Database In-Memory 功能集包括IM列存储、高级查询优化和可用性解决方案。 这些功能结合了在不牺牲OLTP性能或可用性的情况下加快分析查询的数量级。

#### 1.3.1.1 IM 列存储

IM列存储以特殊的压缩列格式保存表、分区和单独列的副本，该格式针对快速扫描进行了优化。 IM列存储驻留在内存区域（In-Memory Area）中，它是系统全局区域（SGA）的可选部分。

IM列存储并不替换基于行的存储或数据库缓冲区高速缓存，而是做为补充。 数据库允许数据以基于行和列的格式存储在内存中，从而提供两者的最佳性能。 IM列存储提供独立于磁盘格式的表数据的附加事务一致性副本。 在IM列存储中填充的对象也不需要加载到缓冲区高速缓存中。

![](http://mmbiz.qpic.cn/mmbiz_png/6F1WRDupvKsDlqDn0CEulljTzptRkWJDnfxaGQ0ckYraq1Ctf8UeSx5C75OiaRiaWgGtwiatzkcNtaOG9CBCUcc6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

图1-2双格式数据库

使用DDL语句中的 INMEMORY 子句在以下任意级别启用IM列存储：

  * 列 (nonvirtual or virtual)
  * 表, 物化视图, 分区
  * 表空间

如果在表空间级别指定 INMEMORY 属性，则缺省情况下，将为表空间中的所有新表和物化视图启用IM列存储。 在 Database In-Memory 中，population是将磁盘上基于行的数据自动转换为IM列存储中的列数据。 您可以配置IM列存储中用于填充的数据库对象的列的全部或子集。 类似地，对于分区表或物化视图，您可以配置全部或分区的子集。

例如，可以将sh schema中的三个表配置为填充到IM列存储：customer，product和sales中。 IM列存储按列而不是按行存储每个表的数据，并将每个列划分为单独的行子集。 称为内存压缩单元（IMCU）的特殊容器存储表段中行的子集的所有列。

#### 1.3.1.2 高级查询优化

Database In-Memory包括针对分析查询的多个性能优化。 优化包括：

  * 表达式是一个或多个值、运算符和SQL函数（仅DETERMINISTIC）的组合，可解析为值。 默认情况下，In-Memory Expression（IM表达式）优化使DBMS_INMEMORY_ADMIN.IME_CAPTURE_EXPRESSIONS过程能够识别和填充IM列存储中的“热”表达式。 IM表达式被实现为隐藏的虚拟列，但是以与非虚拟列相同的方式访问。
  * Join group 是用户定义的对象，用于指定连接查询中的两个或多个表的列。 在某些查询中，连接组使数据库能够消除解压缩和散列列值的性能开销。
  * 对于将小维度表连接到大型实体表的聚合查询，In-Memory Aggregation（IM聚合）使用 VECTOR GROUP BY 操作来提高性能。 在实体表扫描期间优化聚合数据而不是之后。
  * 在IM列存储中，重新填充是IMCU的数据在其中的数据被显着修改后的自动更新。 如果IMCU具有过时的条目但不满足过时阈值，则后台进程可以引起涓流重新填充，这是IM列存储的逐渐重新填充。

#### 1.3.1.3 可高用支持

可用性是指按需访问应用程序、服务或功能的程度。 Database In-Memory 支持以下可用性功能：

In-Memory FastStart（IM FastStart）减少了在数据库实例重新启动时将数据填充到IM列存储的时间。 IM FastStart 通过以压缩列格式定期保存磁盘上当前填充在IM列存储中的数据副本来实现此目的。

Oracle Real Application Clusters（Oracle RAC）环境中的每个节点都有自己的IM列存储。 可以在每个节点上填充完全不同的对象，或者使更大的对象分布在集群中的所有IM列存储上。 在工程化系统中，也可以在每个节点上的IM列存储中显示相同的对象。

从Oracle Database 12c第2版（12.2）开始，Active Data Guard环境中的备库支持IM列存储。

#### 1.3.1.4 提高分析查询的性能

因为IM列存储以压缩列格式填充数据库对象，所以Oracle数据库可以执行更快的扫描、查询、联接和聚合。

#### 1.3.1.5 提高数据扫描的性能

列格式为扫描大量数据提供了快速吞吐量。 您可以实时分析数据，使您可以探索不同的可能性和执行迭代。

IM列存储可以大幅提高以下类型查询的性能：

用于扫描大量行并应用使用诸如<、>、=和IN等运算符的过滤器的查询

从表或具有大量列的物化视图中选择少量列的查询，例如访问100列中5个的查询

对于大多数数字和短字符串数据类型，列格式使用固定宽度的列。 此优化支持快速向量处理，使数据库能够更快地应答查询（请参见“CPU体系结构：SIMD Vector Processing”）。

由于以下原因，IM列存储的扫描比基于行的数据的扫描更快：

  * 消除缓冲区高速缓存开销

  IM列存储以纯in-memory列格式存储数据。 数据不会保留在数据文件中（或生成redo），因此数据库避免了将数据从磁盘读入缓冲区高速缓存的开销。

  * 数据修剪

  数据库仅扫描查询所需的列，而不是整个数据行。 此外，数据库使用存储索引和内部字典来仅读取特定查询所需的IMCU。 例如，如果查询请求商店ID小于8的商店的所有销售，则数据库可以使用IMCU修剪来消除不包含此值的IMCU。

  * 压缩

  传统上，压缩的目的是节省空间。 在IM列存储中，压缩的目标是加速扫描。 数据库使用允许对压缩格式应用 WHERE 子句谓词的算法自动压缩列数据。 根据应用的压缩类型，Oracle数据库可以以其压缩格式扫描数据，而无需首先对其进行解压缩。 因此，数据库必须在IM列存储中扫描的数据量小于数据库缓冲区高速缓存中的相应卷。

  * 矢量处理

  每个CPU核心扫描本地内存列。 将数据作为数组（集合）进行处理，扫描将使用SIMD向量指令。 例如，查询可以读取单个CPU指令中的一组值，而不是逐个读取值。 CPU核心的矢量扫描比行扫描快几个数量级。

  例如，假设用户执行以下即席查询：

  `SELECT cust_id, time_id, channel_id`
  `FROM   sales`
  `WHERE  prod_id BETWEEN 14 and 29`

  当使用缓冲区高速缓存时，数据库通常会扫描索引以查找产品ID，使用rowids从磁盘中取出行到缓冲区高速缓存中，然后丢弃不需要的列值。 在缓冲区高速缓存中以行格式扫描数据需要许多CPU指令，并且可能导致次优的CPU效率。

  使用IM列存储时，数据库只能扫描请求的 sales 列，避免使用磁盘。 以列格式管道扫描数据只需要向CPU提供必要的列，从而提高效率。 每个CPU内核使用SIMD向量指令扫描本地内存中列。

#### 1.3.1.6 改善联接的性能

Bloom filter是一种低内存数据结构，用于测试集合中的成员资格。 IM列存储利用Bloom过滤器来提高连接的性能。

Bloom过滤器通过将小维度表上的谓词转换为大型实体表上的过滤器来加速连接。 当使用一个大实体表执行多个维度的联接时，此优化很有用。 实体表上的维度键有很多重复值。 扫描性能和重复值优化加快连接数量级。

#### 1.3.1.7 提高聚合性能

分析的一个重要方面是通过聚合数据来确定模式和趋势。 当数据存储在IM列存储中时，聚合和复杂SQL查询运行速度更快。

在Oracle数据库中，聚合通常涉及 GROUP BY 子句。 传统上，数据库使用 SORT 和 HASH 运算符。 从Oracle Database 12c Release 1（12.1）开始，数据库提供了 VECTOR GROUP BY 转换以启用高效的内存中基于数组的聚合。

在实体表扫描期间，数据库将聚合值累积到内存数组中，并使用高效算法执行聚合。 基于主键和外键关系的连接针对星型模式和雪花模式进行了优化。

#### 1.3.1.8 提高混合工作负载的性能

虽然OLTP应用程序不能从IM列存储中访问数据，但双内存（dual-memory）格式可以间接提高OLTP性能。

当所有数据存储在行（rows）中时，提高分析查询性能需要创建访问结构。 标准方法是创建分析索引、物化视图和OLAP多维数据集。 例如，表可能需要3个索引来提高OLTP应用程序的性能（1个主键和2个外键索引）和10-20个附加索引，以提高分析查询的性能。 虽然此技术可以提高分析查询性能，但会降低OLTP性能。 在表中插入行需要修改表上的所有索引。 随着索引数量的增加，插入速度降低。

将数据填充到IM列存储中时，可以删除分析访问结构。 此技术减少了存储空间和处理开销，因为只需要更少的索引、物化视图和OLAP多维数据集。 例如，插入数据，将导致修改1-3个索引而不是11-23个索引。

虽然IM列存储可以大幅提高业务应用程序、特殊分析查询和数据仓库工作负载中的分析查询的性能，但使用索引查找执行短事务的纯OLTP数据库更少受益。 IM列存储不会提高以下类型的查询的性能：

  * 具有复杂谓词的查询
  * 用于选择大量列的查询
  * 返回大量行的查询

#### 1.3.1.9 高可用支持

IM列存储完全集成到Oracle数据库中，支持所有高可用性功能。

列格式不会更改Oracle数据库磁盘存储格式。 因此，缓冲区缓存修改和重做日志功能以相同的方式。 完全支持RMAN，Oracle Data Guard和Oracle ASM等功能。

在Oracle Real Application Clusters（Oracle RAC）环境中，默认情况下，每个节点都有自己的IM列存储。 根据您的要求，您可以以不同的方式填充对象：

在每个节点上填充不同的表。 例如，sales 实体表位于一个节点上，而products维度表位于不同的节点上。

单个表分布在不同的节点之间。 例如，同一散列分区（hash-partitioned）表的不同分区在不同节点上，或单个非分区表的不同rowid范围在不同节点上。

某些对象显示在每个节点上的IM列存储中。 例如，您可以在每个节点中填充 products 维度表，但是在不同节点间分布 sales 实体表的分区。

#### 1.3.1.10 易于采用

Database In-Memory 很容易实现，并且不需要更改应用程序。

Database In-Memory 采用的关键方面包括：

  * 易于部署

  不需要用户管理的数据迁移。 数据库以磁盘上的行格式存储数据，并在填充IM列存储时自动将行数据转换为列格式。

  * 与现有应用程序的兼容性

  不需要更改应用程序。 优化器自动利用列格式。 如果应用程序连接到数据库并发出SQL，那么它可以从Database In-Memory功能中受益。

  * 完全SQL兼容性

  Database In-Memory对SQL没有任何限制。 分析查询可以受益，无论他们使用Oracle分析函数还是定制的PL / SQL代码。

  * 易于使用

  不需要复杂的设置。  INMEMORY_SIZE 初始化参数指定保留供IM列存储使用的内存量。 DDL语句中的 INMEMORY 子句指定要填充到IM列存储中的对象或列。 通过配置IM列存储，您可以立即提高现有分析工作负载和即席查询的性能。
